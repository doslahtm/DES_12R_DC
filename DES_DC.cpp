// 올바른 pair 구하는 것 부터 시작
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <vector>
#include <unordered_map>
#include <map>
#include <random>
#include <algorithm>
#include <ctime>
#include "DES.h"

unsigned int key_int[32];

uint64_t S2N = 0;

/*
PT: B3 61 53 A2 0E E8 B1 47 

PT_bar: AA 01 53 A2 0E E8 B1 47 

CT: 10 56 FB 39 F8 0B D6 7A 

CT_bar: DC 5B BA 29 FC 8A D4 7A 

PT_diff: 19 60 00 00 00 00 00 00 

CT_diff: D5 6D 41 10 04 81 02 00 

KEY: 18 7C 16 80 E0 D2 85 1D 

Second Last Sbox Output diff: 10 0 5 0 0 0 0 0 
Destination: 11 
*/

typedef uint64_t u64;
typedef uint32_t u32;
// typedef uint8_t  Byte;
typedef uint64_t Key;

const int SBOX[8][64] = {
    { 14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, },
    { 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, },
    { 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, },
    { 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, },
    { 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, },
    { 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, },
    { 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, },
    { 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11, }
};

uint32_t diff_table[8][64][16];
static uint8_t PC1[56] = {
57, 49, 41, 33, 25, 17, 9,
1, 58, 50, 42, 34, 26, 18,
10, 2, 59, 51, 43, 35, 27,
19, 11, 3, 60, 52, 44, 36,
63, 55, 47, 39, 31, 23, 15,
7, 62, 54, 46, 38, 30, 22,
14, 6, 61, 53, 45, 37, 29,
21, 13, 5, 28, 20, 12, 4,
};

/*
int32_t keysh[] =
{
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1,
};

static uint8_t PC2[48]= {
14, 17, 11, 24, 1, 5, 
3, 28, 15, 6, 21, 10,
23, 19, 12, 4, 26, 8,
16, 7, 27, 20, 13, 2,
41, 52, 31, 37, 47, 55,
30, 40, 51, 45, 33, 48,
44, 49, 39, 56, 34, 53,
46, 42, 50, 36, 29, 32
};

static uint8_t E[] = {
    32,  1,  2,  3,  4,  5,  
    4,  5,  6,  7,  8,  9,  
    8,  9, 10, 11, 12, 13, 
    12, 13, 14, 15, 16, 17, 
    16, 17, 18, 19, 20, 21, 
    20, 21, 22, 23, 24, 25, 
    24, 25, 26, 27, 28, 29, 
    28, 29, 30, 31, 32,  1
};

static uint8_t P[] = {
    16,  7, 20, 21, 
    29, 12, 28, 17, 
    1, 15, 23, 26, 
    5, 18, 31, 10, 
    2,  8, 24, 14, 
    32, 27,  3,  9, 
    19, 13, 30,  6, 
    22, 11,  4, 25
};

*/
int getSBoxOutputVal(byte Intermediate[8], int idx, int dir) {
  byte O[4] = { Intermediate[0 + 4 * dir], Intermediate[1 + 4 * dir], Intermediate[2 + 4 * dir], Intermediate[3 + 4 * dir] };
    switch (idx) {
    case 1: return ((O[1] & 0x80) >> 4) | ((O[2] & 0x80) >> 5) | (O[2] & 0x02) | ((O[3] & 0x02) >> 1);
    case 2: return (O[1] & 0x08) | ((O[3] & 0x10) >> 2) | ((O[0] & 0x40) >> 5) | ((O[2] & 0x40) >> 6);
    case 3: return ((O[2] & 0x01) << 3) | ((O[1] & 0x01) << 2) | ((O[3] & 0x04) >> 1) | ((O[0] & 0x04) >> 2);
    case 4: return ((O[3] & 0x40) >> 3) | ((O[2] & 0x10) >> 2) | ((O[1] & 0x40) >> 5) | ((O[0] & 0x80) >> 7);
    case 5: return ((O[0] & 0x01) << 3) | (O[1] & 0x04) | ((O[3] & 0x80) >> 6) | ((O[0] & 0x20) >> 5);
    case 6: return ((O[0] & 0x10) >> 1) | ((O[3] & 0x08) >> 1) | ((O[1] & 0x20) >> 4) | ((O[2] & 0x20) >> 5);
    case 7: return ((O[3] & 0x01) << 3) | ((O[1] & 0x10) >> 2) | ((O[2] & 0x04) >> 1) | ((O[0] & 0x02) >> 1);
    case 8: return (O[0] & 0x08) | ((O[3] & 0x20) >> 3) | (O[1] & 0x02) | ((O[2] & 0x08) >> 3);
    default: return -1; // unreachable
    }
  return -1; // unreachable
}

int getSBoxInputVal(byte Intermediate[8], int idx, int dir) {
  byte I[4] = { Intermediate[0 + 4 * dir], Intermediate[1 + 4 * dir], Intermediate[2 + 4 * dir], Intermediate[3 + 4 * dir] };
    switch (idx) {
    case 1: return ((I[3] & 0x01) << 5) | ((I[0] & 0xf8) >> 3);
    case 2: return ((I[0] & 0x1f) << 1) | ((I[1] & 0x80) >> 7);
    case 3: return ((I[0] & 0x01) << 5) | ((I[1] & 0xf8) >> 3);
    case 4: return ((I[1] & 0x1f) << 1) | ((I[2] & 0x80) >> 7);
    case 5: return ((I[1] & 0x01) << 5) | ((I[2] & 0xf8) >> 3);
    case 6: return ((I[2] & 0x1f) << 1) | ((I[3] & 0x80) >> 7);
    case 7: return ((I[2] & 0x01) << 5) | ((I[3] & 0xf8) >> 3);
    case 8: return ((I[3] & 0x1f) << 1) | ((I[0] & 0x80) >> 7);
    default: return -1; // unreachable
    }
  return -1; // unreachable
}

/* The S-Box Tables */
static uint8_t S[8][64] = {{
    /* S1 */
    14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,  
    0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,  
    4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0, 
    15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13
},{
    /* S2 */
    15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,  
    3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,  
    0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15, 
    13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9
},{
    /* S3 */
    10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,  
    13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,  
    13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
    1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12
},{
    /* S4 */
    7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,  
    13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,  
    10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
    3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14
},{
    /* S5 */
    2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9, 
    14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6, 
    4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14, 
    11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3
},{
    /* S6 */
    12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
    10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
    9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
    4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13
},{
    /* S7 */
    4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
    13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
    1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
    6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12
},{
    /* S8 */
    13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
    1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
    7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
    2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
}};


byte subkeys[16][6] = {0, };
uint32_t ROUNDS = 12;

void setDiffTable(void);
void setRandomByte(byte content[], int bytesNum);
void permutate(byte in[], byte out[], uint8_t table[], int num);
void print_bytes(byte b[], int num);
void key_schedule(byte key[]);
void generate_subkeys(uint32_t left, uint32_t right);
void check_which_sbox(int key_bit);
// void DES(Byte pt[], Byte ct[]);
int check_is_path(byte pt[], byte pt_bar[]);
void setPtVariant(byte pt[], byte variant[], int idx);
int** getPairList(byte P_list[4096][8], byte P_bar_list[4096][8], byte C_list[4096][8], byte C_bar_list[4096][8], int V_SIZE, int MAX_PAIR);
void recoverSubKey();

// key schedule example reference: https://ritul-patidar.medium.com/key-expansion-function-and-key-schedule-of-des-data-encryption-standard-algorithm-1bfc7476157
/*
11 round 에서 구한 pt pt_bar
PT: 4E B3 F8 BD 0C CF 86 C3 

PT_bar: 4A 33 F8 A9 15 AF 86 C3 

CT: E2 F1 74 A1 B5 B1 B0 FA 

CT_bar: E2 F0 F5 A5 AC D1 B0 FA 

KEY: 49 44 DD BC E0 D1 33 58 

11R!!!
PT: 24 D8 09 07 46 94 51 56 

PT_bar: 20 D8 09 17 5F F4 51 56 

CT: 7C D5 C3 91 75 BD C9 05 

CT_bar: 7C 54 C0 85 6C DD C9 05 

KEY: 2C 39 9C 70 7E 67 30 88 
*/
static int keysh[] =
{
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1,
};
const unsigned int SB1[64] = { 0x00808200,0x00000000,0x00008000,0x00808202,0x00808002,0x00008202,0x00000002,0x00008000,
0x00000200,0x00808200,0x00808202,0x00000200,0x00800202,0x00808002,0x00800000,0x00000002,
0x00000202,0x00800200,0x00800200,0x00008200,0x00008200,0x00808000,0x00808000,0x00800202,
0x00008002,0x00800002,0x00800002,0x00008002,0x00000000,0x00000202,0x00008202,0x00800000,
0x00008000,0x00808202,0x00000002,0x00808000,0x00808200,0x00800000,0x00800000,0x00000200,
0x00808002,0x00008000,0x00008200,0x00800002,0x00000200,0x00000002,0x00800202,0x00008202,
0x00808202,0x00008002,0x00808000,0x00800202,0x00800002,0x00000202,0x00008202,0x00808200,
0x00000202,0x00800200,0x00800200,0x00000000,0x00008002,0x00008200,0x00000000,0x00808002 };
const unsigned int SB2[64] = { 0x40084010,0x40004000,0x00004000,0x00084010,0x00080000,0x00000010,0x40080010,0x40004010,
0x40000010,0x40084010,0x40084000,0x40000000,0x40004000,0x00080000,0x00000010,0x40080010,
0x00084000,0x00080010,0x40004010,0x00000000,0x40000000,0x00004000,0x00084010,0x40080000,
0x00080010,0x40000010,0x00000000,0x00084000,0x00004010,0x40084000,0x40080000,0x00004010,
0x00000000,0x00084010,0x40080010,0x00080000,0x40004010,0x40080000,0x40084000,0x00004000,
0x40080000,0x40004000,0x00000010,0x40084010,0x00084010,0x00000010,0x00004000,0x40000000,
0x00004010,0x40084000,0x00080000,0x40000010,0x00080010,0x40004010,0x40000010,0x00080010,
0x00084000,0x00000000,0x40004000,0x00004010,0x40000000,0x40080010,0x40084010,0x00084000 };
const unsigned int SB3[64] = { 0x00000104,0x04010100,0x00000000,0x04010004,0x04000100,0x00000000,0x00010104,0x04000100,
0x00010004,0x04000004,0x04000004,0x00010000,0x04010104,0x00010004,0x04010000,0x00000104,
0x04000000,0x00000004,0x04010100,0x00000100,0x00010100,0x04010000,0x04010004,0x00010104,
0x04000104,0x00010100,0x00010000,0x04000104,0x00000004,0x04010104,0x00000100,0x04000000,
0x04010100,0x04000000,0x00010004,0x00000104,0x00010000,0x04010100,0x04000100,0x00000000,
0x00000100,0x00010004,0x04010104,0x04000100,0x04000004,0x00000100,0x00000000,0x04010004,
0x04000104,0x00010000,0x04000000,0x04010104,0x00000004,0x00010104,0x00010100,0x04000004,
0x04010000,0x04000104,0x00000104,0x04010000,0x00010104,0x00000004,0x04010004,0x00010100 };
const unsigned int SB4[64] = { 0x80401000,0x80001040,0x80001040,0x00000040,0x00401040,0x80400040,0x80400000,0x80001000,
0x00000000,0x00401000,0x00401000,0x80401040,0x80000040,0x00000000,0x00400040,0x80400000,
0x80000000,0x00001000,0x00400000,0x80401000,0x00000040,0x00400000,0x80001000,0x00001040,
0x80400040,0x80000000,0x00001040,0x00400040,0x00001000,0x00401040,0x80401040,0x80000040,
0x00400040,0x80400000,0x00401000,0x80401040,0x80000040,0x00000000,0x00000000,0x00401000,
0x00001040,0x00400040,0x80400040,0x80000000,0x80401000,0x80001040,0x80001040,0x00000040,
0x80401040,0x80000040,0x80000000,0x00001000,0x80400000,0x80001000,0x00401040,0x80400040,
0x80001000,0x00001040,0x00400000,0x80401000,0x00000040,0x00400000,0x00001000,0x00401040 };
const unsigned int SB5[64] = { 0x00000080,0x01040080,0x01040000,0x21000080,0x00040000,0x00000080,0x20000000,0x01040000,
0x20040080,0x00040000,0x01000080,0x20040080,0x21000080,0x21040000,0x00040080,0x20000000,
0x01000000,0x20040000,0x20040000,0x00000000,0x20000080,0x21040080,0x21040080,0x01000080,
0x21040000,0x20000080,0x00000000,0x21000000,0x01040080,0x01000000,0x21000000,0x00040080,
0x00040000,0x21000080,0x00000080,0x01000000,0x20000000,0x01040000,0x21000080,0x20040080,
0x01000080,0x20000000,0x21040000,0x01040080,0x20040080,0x00000080,0x01000000,0x21040000,
0x21040080,0x00040080,0x21000000,0x21040080,0x01040000,0x00000000,0x20040000,0x21000000,
0x00040080,0x01000080,0x20000080,0x00040000,0x00000000,0x20040000,0x01040080,0x20000080 };
const unsigned int SB6[64] = { 0x10000008,0x10200000,0x00002000,0x10202008,0x10200000,0x00000008,0x10202008,0x00200000,
0x10002000,0x00202008,0x00200000,0x10000008,0x00200008,0x10002000,0x10000000,0x00002008,
0x00000000,0x00200008,0x10002008,0x00002000,0x00202000,0x10002008,0x00000008,0x10200008,
0x10200008,0x00000000,0x00202008,0x10202000,0x00002008,0x00202000,0x10202000,0x10000000,
0x10002000,0x00000008,0x10200008,0x00202000,0x10202008,0x00200000,0x00002008,0x10000008,
0x00200000,0x10002000,0x10000000,0x00002008,0x10000008,0x10202008,0x00202000,0x10200000,
0x00202008,0x10202000,0x00000000,0x10200008,0x00000008,0x00002000,0x10200000,0x00202008,
0x00002000,0x00200008,0x10002008,0x00000000,0x10202000,0x10000000,0x00200008,0x10002008 };
const unsigned int SB7[64] = { 0x00100000,0x02100001,0x02000401,0x00000000,0x00000400,0x02000401,0x00100401,0x02100400,
0x02100401,0x00100000,0x00000000,0x02000001,0x00000001,0x02000000,0x02100001,0x00000401,
0x02000400,0x00100401,0x00100001,0x02000400,0x02000001,0x02100000,0x02100400,0x00100001,
0x02100000,0x00000400,0x00000401,0x02100401,0x00100400,0x00000001,0x02000000,0x00100400,
0x02000000,0x00100400,0x00100000,0x02000401,0x02000401,0x02100001,0x02100001,0x00000001,
0x00100001,0x02000000,0x02000400,0x00100000,0x02100400,0x00000401,0x00100401,0x02100400,
0x00000401,0x02000001,0x02100401,0x02100000,0x00100400,0x00000000,0x00000001,0x02100401,
0x00000000,0x00100401,0x02100000,0x00000400,0x02000001,0x02000400,0x00000400,0x00100001 };
const unsigned int SB8[64] = { 0x08000820,0x00000800,0x00020000,0x08020820,0x08000000,0x08000820,0x00000020,0x08000000,
0x00020020,0x08020000,0x08020820,0x00020800,0x08020800,0x00020820,0x00000800,0x00000020,
0x08020000,0x08000020,0x08000800,0x00000820,0x00020800,0x00020020,0x08020020,0x08020800,
0x00000820,0x00000000,0x00000000,0x08020020,0x08000020,0x08000800,0x00020820,0x00020000,
0x00020820,0x00020000,0x08020800,0x00000800,0x00000020,0x08020020,0x00000800,0x00020820,
0x08000800,0x00000020,0x08000020,0x08020000,0x08020020,0x08000000,0x00020000,0x08000820,
0x00000000,0x08020820,0x00020020,0x08000020,0x08020000,0x08000800,0x08000820,0x00000000,
0x08020820,0x00020800,0x00020800,0x00000820,0x00000820,0x00020020,0x08000000,0x08020800 };
static unsigned int comptab[] = {

    0x000000,0x010000,0x000008,0x010008,0x000080,0x010080,0x000088,0x010088,
    0x000000,0x010000,0x000008,0x010008,0x000080,0x010080,0x000088,0x010088,

    0x000000,0x100000,0x000800,0x100800,0x000000,0x100000,0x000800,0x100800,
    0x002000,0x102000,0x002800,0x102800,0x002000,0x102000,0x002800,0x102800,

    0x000000,0x000004,0x000400,0x000404,0x000000,0x000004,0x000400,0x000404,
    0x400000,0x400004,0x400400,0x400404,0x400000,0x400004,0x400400,0x400404,

    0x000000,0x000020,0x008000,0x008020,0x800000,0x800020,0x808000,0x808020,
    0x000002,0x000022,0x008002,0x008022,0x800002,0x800022,0x808002,0x808022,

    0x000000,0x000200,0x200000,0x200200,0x001000,0x001200,0x201000,0x201200,
    0x000000,0x000200,0x200000,0x200200,0x001000,0x001200,0x201000,0x201200,

    0x000000,0x000040,0x000010,0x000050,0x004000,0x004040,0x004010,0x004050,
    0x040000,0x040040,0x040010,0x040050,0x044000,0x044040,0x044010,0x044050,

    0x000000,0x000100,0x020000,0x020100,0x000001,0x000101,0x020001,0x020101,
    0x080000,0x080100,0x0a0000,0x0a0100,0x080001,0x080101,0x0a0001,0x0a0101,

    0x000000,0x000100,0x040000,0x040100,0x000000,0x000100,0x040000,0x040100,
    0x000040,0x000140,0x040040,0x040140,0x000040,0x000140,0x040040,0x040140,

    0x000000,0x400000,0x008000,0x408000,0x000008,0x400008,0x008008,0x408008,
    0x000400,0x400400,0x008400,0x408400,0x000408,0x400408,0x008408,0x408408,

    0x000000,0x001000,0x080000,0x081000,0x000020,0x001020,0x080020,0x081020,
    0x004000,0x005000,0x084000,0x085000,0x004020,0x005020,0x084020,0x085020,

    0x000000,0x000800,0x000000,0x000800,0x000010,0x000810,0x000010,0x000810,
    0x800000,0x800800,0x800000,0x800800,0x800010,0x800810,0x800010,0x800810,

    0x000000,0x010000,0x000200,0x010200,0x000000,0x010000,0x000200,0x010200,
    0x100000,0x110000,0x100200,0x110200,0x100000,0x110000,0x100200,0x110200,

    0x000000,0x000004,0x000000,0x000004,0x000080,0x000084,0x000080,0x000084,
    0x002000,0x002004,0x002000,0x002004,0x002080,0x002084,0x002080,0x002084,

    0x000000,0x000001,0x200000,0x200001,0x020000,0x020001,0x220000,0x220001,
    0x000002,0x000003,0x200002,0x200003,0x020002,0x020003,0x220002,0x220003,
};

static void
keycompperm(unsigned int left, unsigned int right, unsigned int *ek)
{
    unsigned int v0, v1;
    int i;

    for (i = 0; i < 16; i++) {
        left = (left << keysh[i]) | (left >> (28 - keysh[i]));
        left &= 0xfffffff0;
        right = (right << keysh[i]) | (right >> (28 - keysh[i]));
        right &= 0xfffffff0;
        v0 = comptab[6 * (1 << 4) + ((left >> (32 - 4)) & 0xf)]
        | comptab[5 * (1 << 4) + ((left >> (32 - 8)) & 0xf)]
        | comptab[4 * (1 << 4) + ((left >> (32 - 12)) & 0xf)]
        | comptab[3 * (1 << 4) + ((left >> (32 - 16)) & 0xf)]
        | comptab[2 * (1 << 4) + ((left >> (32 - 20)) & 0xf)]
        | comptab[1 * (1 << 4) + ((left >> (32 - 24)) & 0xf)]
        | comptab[0 * (1 << 4) + ((left >> (32 - 28)) & 0xf)];
        v1 = comptab[13 * (1 << 4) + ((right >> (32 - 4)) & 0xf)]
        | comptab[12 * (1 << 4) + ((right >> (32 - 8)) & 0xf)]
        | comptab[11 * (1 << 4) + ((right >> (32 - 12)) & 0xf)]
        | comptab[10 * (1 << 4) + ((right >> (32 - 16)) & 0xf)]
        | comptab[9 * (1 << 4) + ((right >> (32 - 20)) & 0xf)]
        | comptab[8 * (1 << 4) + ((right >> (32 - 24)) & 0xf)]
        | comptab[7 * (1 << 4) + ((right >> (32 - 28)) & 0xf)];
        ek[0] = (((v0 >> (24 - 6)) & 0x3f) << 26)
        | (((v0 >> (24 - 18)) & 0x3f) << 18)
        | (((v1 >> (24 - 6)) & 0x3f) << 10)
        | (((v1 >> (24 - 18)) & 0x3f) << 2);
        ek[1] = (((v0 >> (24 - 12)) & 0x3f) << 26)
        | (((v0 >> (24 - 24)) & 0x3f) << 18)
        | (((v1 >> (24 - 12)) & 0x3f) << 10)
        | (((v1 >> (24 - 24)) & 0x3f) << 2);
        ek += 2;
    }
}

void des_key_setup(byte key[8], unsigned int *ek)
{
    unsigned int left, right, v0, v1;

    v0 = key[0] | ((unsigned int)key[2] << 8) | ((unsigned int)key[4] << 16) | ((unsigned int)key[6] << 24);
    v1 = key[1] | ((unsigned int)key[3] << 8) | ((unsigned int)key[5] << 16) | ((unsigned int)key[7] << 24);
    left = ((v0 >> 1) & 0x40404040)
        | ((v0 >> 2) & 0x10101010)
        | ((v0 >> 3) & 0x04040404)
        | ((v0 >> 4) & 0x01010101)
        | ((v1 >> 0) & 0x80808080)
        | ((v1 >> 1) & 0x20202020)
        | ((v1 >> 2) & 0x08080808)
        | ((v1 >> 3) & 0x02020202);
    right = ((v0 >> 1) & 0x04040404)
        | ((v0 << 2) & 0x10101010)
        | ((v0 << 5) & 0x40404040)
        | ((v1 << 0) & 0x08080808)
        | ((v1 << 3) & 0x20202020)
        | ((v1 << 6) & 0x80808080);
    left = ((left << 6) & 0x33003300)
        | (left & 0xcc33cc33)
        | ((left >> 6) & 0x00cc00cc);
    v0 = ((left << 12) & 0x0f0f0000)
        | (left & 0xf0f00f0f)
        | ((left >> 12) & 0x0000f0f0);
    right = ((right << 6) & 0x33003300)
        | (right & 0xcc33cc33)
        | ((right >> 6) & 0x00cc00cc);
    v1 = ((right << 12) & 0x0f0f0000)
        | (right & 0xf0f00f0f)
        | ((right >> 12) & 0x0000f0f0);
    left = v0 & 0xfffffff0;
    right = (v1 & 0xffffff00) | ((v0 << 4) & 0xf0);

    keycompperm(left, right, ek);
}

void DES(unsigned int* key, byte* text, byte* C)
{
    unsigned int right, left, v0, v1;
    left = text[3] | ((unsigned int)text[2] << 8) | ((unsigned int)text[1] << 16) | ((unsigned int)text[0] << 24);
    right = text[7] | ((unsigned int)text[6] << 8) | ((unsigned int)text[5] << 16) | ((unsigned int)text[4] << 24);
    
    v0 = key[0];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[1];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[2];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[3];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v0 = key[4];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[5];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[6];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[7];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v0 = key[8];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[9];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[10];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[11];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v0 = key[12];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[13];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[14];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[15];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v0 = key[16];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[17];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[18];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[19];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v0 = key[20];
    v0 ^= (right >> 1) | (right << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    
    v1 = key[21];
    v1 ^= (right << 3) | (right >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];

    v0 = key[22];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v1 = key[23];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
        
     
    v0 = left;
    v1 = right;
    C[7] = v0;
    C[6] = v0 >> 8;
    C[5] = v0 >> 16;
    C[4] = v0 >> 24;
    C[3] = v1;
    C[2] = v1 >> 8;
    C[1] = v1 >> 16;
    C[0] = v1 >> 24;
}




int isRightPath(unsigned int* key, byte* text, byte* text_bar)
{
    unsigned int right, left, v0, v1;
    left = text[3] | ((unsigned int)text[2] << 8) | ((unsigned int)text[1] << 16) | ((unsigned int)text[0] << 24);
    right = text[7] | ((unsigned int)text[6] << 8) | ((unsigned int)text[5] << 16) | ((unsigned int)text[4] << 24);
    
    unsigned int right_bar, left_bar, v0_bar, v1_bar;
    left_bar = text_bar[3] | ((unsigned int)text_bar[2] << 8) | ((unsigned int)text_bar[1] << 16) | ((unsigned int)text_bar[0] << 24);
    right_bar = text_bar[7] | ((unsigned int)text_bar[6] << 8) | ((unsigned int)text_bar[5] << 16) | ((unsigned int)text_bar[4] << 24);

    
    v0 = key[0];
    v0_bar = key[0];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[1];
    v1_bar = key[1];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];
    if (left != left_bar)
        return -1;
    v0 = key[2];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[2];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[3];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[3];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];


    v0 = key[4];
    v0_bar = key[4];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[5];
    v1_bar = key[5];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];
    if (left != left_bar)
        return 4;
    v0 = key[6];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[6];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[7];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[7];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];

    v0 = key[8];
    v0_bar = key[8];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[9];
    v1_bar = key[9];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];
    if (left != left_bar)
        return 6;

    v0 = key[10];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[10];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[11];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[11];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];


    v0 = key[12];
    v0_bar = key[12];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[13];
    v1_bar = key[13];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];
    if (left != left_bar)
        return 8;
    v0 = key[14];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[14];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[15];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[15];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];


    v0 = key[16];
    v0_bar = key[16];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[17];
    v1_bar = key[17];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];
    if (left != left_bar)
        return 10;
    v0 = key[18];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[18];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[19];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[19];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];


    v0 = key[20];
    v0_bar = key[20];
    v0 ^= (right >> 1) | (right << 31);
    v0_bar ^= (right_bar >> 1) | (right_bar << 31);
    left ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    left_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[21];
    v1_bar = key[21];
    v1 ^= (right << 3) | (right >> 29);
    v1_bar ^= (right_bar << 3) | (right_bar >> 29);
    left ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    left_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];

    v0 = key[22];
    v0 ^= (left >> 1) | (left << 31);
    right ^= SB1[(v0 >> 26) & 0x3f]
        ^ SB3[(v0 >> 18) & 0x3f]
        ^ SB5[(v0 >> 10) & 0x3f]
        ^ SB7[(v0 >> 2) & 0x3f];
    v0_bar = key[22];
    v0_bar ^= (left_bar >> 1) | (left_bar << 31);
    right_bar ^= SB1[(v0_bar >> 26) & 0x3f]
        ^ SB3[(v0_bar >> 18) & 0x3f]
        ^ SB5[(v0_bar >> 10) & 0x3f]
        ^ SB7[(v0_bar >> 2) & 0x3f];
    
    v1 = key[23];
    v1 ^= (left << 3) | (left >> 29);
    right ^= SB2[(v1 >> 26) & 0x3f]
        ^ SB4[(v1 >> 18) & 0x3f]
        ^ SB6[(v1 >> 10) & 0x3f]
        ^ SB8[(v1 >> 2) & 0x3f];
    v1_bar = key[23];
    v1_bar ^= (left_bar << 3) | (left_bar >> 29);
    right_bar ^= SB2[(v1_bar >> 26) & 0x3f]
        ^ SB4[(v1_bar >> 18) & 0x3f]
        ^ SB6[(v1_bar >> 10) & 0x3f]
        ^ SB8[(v1_bar >> 2) & 0x3f];

    
    return 12;
}

int recoverKey(byte pt[8], byte ct[8], byte pt_bar[8], byte ct_bar[8]) {
    uint8_t keybit[56] = {0, };
    // (23, 19, 12, 4, 26, 8) 번째 left register 복구
    for (uint32_t r1s3 = 0; r1s3 < 64; r1s3++) {
        keybit[23] = (r1s3 >> 5);
        keybit[19] = (r1s3 >> 4) & 1;
        keybit[12] = (r1s3 >> 3) & 1;
        keybit[4] = (r1s3 >> 2) & 1;
        keybit[26] = (r1s3 >> 1) & 1;
        keybit[8] = (r1s3) & 1;
        uint32_t R1S3_key = r1s3;
        uint32_t R1S3_input1 = getSBoxInputVal(pt, 3, 1);
        uint32_t R1S3_input2 = getSBoxInputVal(pt_bar, 3, 1);
        uint32_t R1S3_output1 = SBOX[2][R1S3_key ^ R1S3_input1];
        uint32_t R1S3_output2 = SBOX[2][R1S3_key ^ R1S3_input2];
        uint32_t R1S3_output_diff = R1S3_output1 ^ R1S3_output2;
        uint32_t right_R1S3_output_diff = getSBoxOutputVal(pt, 3, 0) ^ getSBoxOutputVal(pt_bar, 3, 0);
        if (R1S3_output_diff != right_R1S3_output_diff)
            continue;
        // 맞다면, R12 S4에서 공통키 이오에 (8, 27, 19, 12, 5, 22) 중 (27, 5, 22) 복구
        for (uint32_t r12s4 = 0; r12s4 < 8; r12s4++) {
            keybit[27] = (r12s4 >> 2) & 1;
            keybit[5] = (r12s4 >> 1) & 1;
            keybit[22] = (r12s4) & 1;
            uint32_t R12S4_key = keybit[8] << 5 | keybit[27] << 4 | keybit[19] << 3 | keybit[12] << 2 | keybit[5] << 1 | keybit[22];
            uint32_t R12S4_input1 = getSBoxInputVal(ct, 4, 1);
            uint32_t R12S4_input2 = getSBoxInputVal(ct_bar, 4, 1);
            uint32_t R12S4_output1 = SBOX[3][R12S4_key ^ R12S4_input1];
            uint32_t R12S4_output2 = SBOX[3][R12S4_key ^ R12S4_input2];
            uint32_t R12S4_output_diff = R12S4_output1 ^ R12S4_output2;
            uint32_t right_R12S4_output_diff = getSBoxOutputVal(ct, 4, 0) ^ getSBoxOutputVal(ct_bar, 4, 0) ^ 0x2;
            if (R12S4_output_diff != right_R12S4_output_diff)
                continue;
            // ROUND12 S2(23 20 7 26 13 2) 20 7 13 2를 정해야함
            for (uint32_t r12s2 = 0; r12s2 < 16; r12s2++) {
                keybit[20] = (r12s2 >> 3) & 1;
                keybit[7] = (r12s2 >> 2) & 1;
                keybit[13] = (r12s2 >> 1) & 1;
                keybit[2] = (r12s2) & 1;
                uint32_t R12S2_key = keybit[23] << 5 | keybit[20] << 4 | keybit[7] << 3 | keybit[26] << 2 | keybit[13] << 1 | keybit[2];
                uint32_t R12S2_input1 = getSBoxInputVal(ct, 2, 1);
                uint32_t R12S2_input2 = getSBoxInputVal(ct_bar, 2, 1);
                uint32_t R12S2_output1 = SBOX[1][R12S2_key ^ R12S2_input1];
                uint32_t R12S2_output2 = SBOX[1][R12S2_key ^ R12S2_input2];
                uint32_t R12S2_output_diff = R12S2_output1 ^ R12S2_output2;
                uint32_t right_R12S2_output_diff = getSBoxOutputVal(ct, 2, 0) ^ getSBoxOutputVal(ct_bar, 2, 0);
                if (R12S2_output_diff != right_R12S2_output_diff)
                    continue;
                //ROUND1 S2(3 0 15 6 21 10). 모든 비트를 다 정해야됨
                for (uint32_t r1s2 = 0; r1s2 < 64; r1s2++) {
                    keybit[3] = (r1s2 >> 5);
                    keybit[0] = (r1s2 >> 4) & 1;
                    keybit[15] = (r1s2 >> 3) & 1;
                    keybit[6] = (r1s2 >> 2) & 1;
                    keybit[21] = (r1s2 >> 1) & 1;
                    keybit[10] = (r1s2) & 1;
                    uint32_t R1S2_key = r1s2;
                    uint32_t R1S2_input1 = getSBoxInputVal(pt, 2, 1);
                    uint32_t R1S2_input2 = getSBoxInputVal(pt_bar, 2, 1);
                    uint32_t R1S2_output1 = SBOX[1][R1S2_key ^ R1S2_input1];
                    uint32_t R1S2_output2 = SBOX[1][R1S2_key ^ R1S2_input2];
                    uint32_t R1S2_output_diff = R1S2_output1 ^ R1S2_output2;
                    uint32_t right_R1S2_output_diff = getSBoxOutputVal(pt, 2, 0) ^ getSBoxOutputVal(pt_bar, 2, 0);
                    if (R1S2_output_diff != right_R1S2_output_diff)
                        continue;
                    // R12S1 (6, 9, 3, 16, 21, 25) (9, 16, 25) 복구

                    for (uint32_t r12s1 = 0; r12s1 < 8; r12s1++) {
                        keybit[9] = (r12s1 >> 2) & 1;
                        keybit[16] = (r12s1 >> 1) & 1;
                        keybit[25] = (r12s1) & 1;
                        int R12S1_key = (keybit[6] << 5) | (keybit[9] << 4) | (keybit[3] << 3) | (keybit[16] << 2) | (keybit[21] << 1) | keybit[25];
                        int R12S1_input1 = getSBoxInputVal(ct, 1, 1);
                        int R12S1_input2 = getSBoxInputVal(ct_bar, 1, 1);

                        int R12S1_output1 = SBOX[0][R12S1_key ^ R12S1_input1];
                        int R12S1_output2 = SBOX[0][R12S1_key ^ R12S1_input2];
                        int R12S1_output_diff = R12S1_output1 ^ R12S1_output2;
                        int right_R12S1_output_diff = getSBoxOutputVal(ct, 1, 0) ^ getSBoxOutputVal(ct_bar, 1, 0);
                        if (R12S1_output_diff != right_R12S1_output_diff)
                            continue;

                        // R12S3 (15, 11, 4, 24, 18, 0,) 중 (11, 24, 18) 복구
                        for (uint32_t r12s3 = 0; r12s3 < 8; r12s3++) {
                            keybit[11] = (r12s3 >> 2) & 1;
                            keybit[24] = (r12s3 >> 1) & 1;
                            keybit[18] = (r12s3) & 1;
                            uint32_t R12S3_key = keybit[15] << 5 | keybit[11] << 4 | keybit[4] << 3 | keybit[24] << 2 | keybit[18] << 1 | keybit[0];
                            uint32_t R12S3_input1 = getSBoxInputVal(ct, 3, 1);
                            uint32_t R12S3_input2 = getSBoxInputVal(ct_bar, 3, 1);
                            uint32_t R12S3_output1 = SBOX[2][R12S3_key ^ R12S3_input1];
                            uint32_t R12S3_output2 = SBOX[2][R12S3_key ^ R12S3_input2];
                            uint32_t R12S3_output_diff = R12S3_output1 ^ R12S3_output2;
                            uint32_t right_R12S3_output_diff = getSBoxOutputVal(ct, 3, 0) ^ getSBoxOutputVal(ct_bar, 3, 0);
                            if (R12S3_output_diff != right_R12S3_output_diff)
                                continue;
                            // 마지막 left R1S1 (14 17 11 24 1 5) 중 (14, 17, 1) 복구
                            for (uint32_t r1s1 = 0; r1s1 < 8; r1s1++) {
                                keybit[14] = (r1s1 >> 2) & 1;
                                keybit[17] = (r1s1 >> 1) & 1;
                                keybit[1] = (r1s1) & 1;
                                uint32_t R1S1_key = keybit[14] << 5 | keybit[17] << 4 | keybit[11] << 3 | keybit[24] << 2 | keybit[1] << 1 | keybit[5];
                                uint32_t R1S1_input1 = getSBoxInputVal(pt, 1, 1);
                                uint32_t R1S1_input2 = getSBoxInputVal(pt_bar, 1, 1);
                                uint32_t R1S1_output1 = SBOX[0][R1S1_input1 ^ R1S1_key];
                                uint32_t R1S1_output2 = SBOX[0][R1S1_input2 ^ R1S1_key];
                                uint32_t R1S1_output_diff = R1S1_output1 ^ R1S1_output2;
                                uint32_t right_R1S1_output_diff = getSBoxOutputVal(pt, 1, 0) ^ getSBoxOutputVal(pt_bar, 1, 0);
                                if (R1S1_output_diff != right_R1S1_output_diff)
                                    continue;
                                
                                // left key register recover over
                                // right key 24bits turn
                                // R11S1 diff 0x03
                                uint8_t R12_output1[32] = {0, };
                                uint8_t R12_output2[32] = {0, };
                                // keybit (4, 7, 1, 14, 19, 23)
                                // R12_output (24 15 6 19 20 28) 중 (24, 19, 20, 28) 지정
                                for (uint32_t r11s1 = 0; r11s1 < 16; r11s1++) {
                                    uint32_t R11S1_key = keybit[4] << 5 | keybit[7] << 4 | keybit[1] << 3 | keybit[14] << 2 | keybit[19] << 1 | keybit[23];
                                    R12_output1[24] = (r11s1 >> 3) & 1;
                                    uint32_t b2 = R12S4_output1 & 1;
                                    uint32_t b3 = (R12S2_output1 >> 1) & 1;
                                    R12_output1[19] = (r11s1 >> 2) & 1;
                                    R12_output1[20] = (r11s1 >> 1) & 1;
                                    R12_output1[28] = (r11s1) & 1;
                                    uint32_t R11S1_input1 = R12_output1[24] << 5 | b2 << 4 | b3 << 3 | R12_output1[19] << 2 | R12_output1[20] << 1 | R12_output1[28];
                                    R11S1_input1 ^= getSBoxInputVal(ct, 1, 0);
                                    uint32_t R11S1_input2 = R11S1_input1 ^ 0x03;
                                    uint32_t R11S1_output1 = SBOX[0][R11S1_input1 ^ R11S1_key];
                                    uint32_t R11S1_output2 = SBOX[0][R11S1_input2 ^ R11S1_key];
                                    uint32_t R11S1_output_diff = R11S1_output1 ^ R11S1_output2;
                                    uint32_t right_R11S1_output_diff = getSBoxOutputVal(ct, 1, 1) ^ getSBoxOutputVal(ct_bar, 1, 1);
                                    if (R11S1_output_diff != right_R11S1_output_diff)
                                        continue;
                                    uint32_t tmp = R11S1_input2 ^ getSBoxInputVal(ct_bar, 1, 0);
                                    R12_output2[24] = (tmp >> 5) & 1;
                                    R12_output2[19] = (tmp >> 2) & 1;
                                    R12_output2[20] = (tmp >> 1) & 1;
                                    R12_output2[28] = (tmp) & 1;
                                    // Round11 S2에서 input XOR은 0x32이다.
                                    // Permutation S2 : 20 28 11 27 16 0, 27 16 값을 임의로 정해야 함
                                    // keybit (21, 18, 5, 24, 11, 0,)
                                    for (uint32_t r11s2 = 0; r11s2 < 4; r11s2++) {
                                        uint32_t R11S2_key = keybit[21] << 5 | keybit[18] << 4 | keybit[5] << 3 | keybit[24] << 2 | keybit[11] << 1 | keybit[0];
                                        uint32_t b3 = R12S3_output1 & 1;
                                        R12_output1[27] = (r11s2 >> 1) & 1;
                                        R12_output1[16] = (r11s2) & 1;
                                        uint32_t b6 = (R12S1_output1 >> 3) & 1;
                                        uint32_t R11S2_input1 = R12_output1[20] << 5 | R12_output1[28] << 4 | b3 << 3 | R12_output1[27] << 2 | R12_output1[16] << 1 | b6;
                                        R11S2_input1 ^= getSBoxInputVal(ct, 2, 0);
                                        uint32_t R11S2_input2 = R11S2_input1 ^ 0x32;
                                        uint32_t R11S2_output1 = SBOX[1][R11S2_input1 ^ R11S2_key];
                                        uint32_t R11S2_output2 = SBOX[1][R11S2_input2 ^ R11S2_key];
                                        uint32_t R11S2_output_diff = R11S2_output1 ^ R11S2_output2;
                                        uint32_t right_R11S2_output_diff = getSBoxOutputVal(ct, 2, 1) ^ getSBoxOutputVal(ct_bar, 2, 1);
                                        if (R11S2_output_diff != right_R11S2_output_diff)
                                            continue;
                                        uint32_t tmp = R11S2_input2 ^ getSBoxInputVal(ct_bar, 2, 0);
                                        R12_output2[27] = (tmp >> 2) & 1;
                                        R12_output2[16] = (tmp >> 1) & 1;
                                        // Round11 S3에서 input XOR은 0x2c이다.
                                        // Permutation S3 : 16 0 14 22 25 4, 22 25 값을 임의로 정해야 함
                                        // keybit (13, 9, 2, 22, 16, 26)
                                        for (uint32_t r11s3 = 0; r11s3 < 4; r11s3++) {
                                            uint32_t R11S3_key = keybit[13] << 5 | keybit[9] << 4 | keybit[2] << 3 | keybit[22] << 2 | keybit[16] << 1 | keybit[26];
                                            uint32_t b2 = (R12S1_output1 >> 3) & 1;
                                            uint32_t b3_ = (R12S4_output1 >> 1) & 1;
                                            R12_output1[22] = (r11s3 >> 1) & 1;
                                            R12_output1[25] = (r11s3) & 1;
                                            uint32_t b6 = (R12S2_output1 >> 3) & 1;
                                            uint32_t R11S3_input1 = R12_output1[16] << 5 | b2 << 4 | b3_ << 3 | R12_output1[22] << 2 | R12_output1[25] << 1 | b6;
                                            R11S3_input1 ^= getSBoxInputVal(ct, 3, 0);
                                            uint32_t R11S3_input2 = R11S3_input1 ^ 0x2c;
                                            uint32_t R11S3_output1 = SBOX[2][R11S3_input1 ^ R11S3_key];
                                            uint32_t R11S3_output2 = SBOX[2][R11S3_input2 ^ R11S3_key];
                                            uint32_t R11S3_output_diff = R11S3_output1 ^ R11S3_output2;
                                            uint32_t right_R11S3_output_diff = getSBoxOutputVal(ct, 3, 1) ^ getSBoxOutputVal(ct_bar, 3, 1);
                                            if (R11S3_output_diff != right_R11S3_output_diff)
                                                continue;
                                            uint32_t tmp = R11S3_input2 ^ getSBoxInputVal(ct_bar, 3, 0);
                                            R12_output2[22] = (tmp >> 2) & 1;
                                            R12_output2[25] = (tmp >> 1) & 1;

                                            // Round 12 S5~S8까지 차분을 15라운드에서 토대로 복원한 부분 sbox output 비트를 보고 판단
                                            // keybit (33 44 51 29 39 47)
                                            // output bit가 16 ~ 19인데 16, 19비트를 알고 있음
                                            for (uint32_t r12s5 = 0; r12s5 < 64; r12s5++) {
                                                keybit[33] = (r12s5 >> 5) & 1;
                                                keybit[44] = (r12s5 >> 4) & 1;
                                                keybit[51] = (r12s5 >> 3) & 1;
                                                keybit[29] = (r12s5 >> 2) & 1;
                                                keybit[39] = (r12s5 >> 1) & 1;
                                                keybit[47] = (r12s5) & 1;
                                                uint32_t R12S5_key = r12s5;
                                                uint32_t R12S5_input1 = getSBoxInputVal(ct, 5, 1);
                                                uint32_t R12S5_input2 = getSBoxInputVal(ct_bar, 5, 1);
                                                if ((SBOX[4][R12S5_input1 ^ R12S5_key] & 0x09) != (R12_output1[16]<< 3 | R12_output1[19]))
                                                    continue;
                                                if ((SBOX[4][R12S5_input2 ^ R12S5_key] & 0x09) != (R12_output2[16]<< 3 | R12_output2[19]))
                                                    continue;
                                                uint32_t tmp = SBOX[4][R12S5_input1 ^ R12S5_key];
                                                R12_output1[17] = (tmp >> 2) & 1;
                                                R12_output1[18] = (tmp >> 1) & 1;
                                                tmp = SBOX[4][R12S5_input2 ^ R12S5_key];
                                                R12_output2[17] = (tmp >> 2) & 1;
                                                R12_output2[18] = (tmp >> 1) & 1;
                                                
                                                // Round12 S6 keybit (50 32 43 37 53 40)
                                                // Round12 output bit (20 21 22 23) 중 (20, 22) 알고있음
                                                for (uint32_t r12s6 = 0; r12s6 < 64; r12s6++) {
                                                    keybit[50] = (r12s6 >> 5) & 1;
                                                    keybit[32] = (r12s6 >> 4) & 1;
                                                    keybit[43] = (r12s6 >> 3) & 1;
                                                    keybit[37] = (r12s6 >> 2) & 1;
                                                    keybit[53] = (r12s6 >> 1) & 1;
                                                    keybit[40] = (r12s6) & 1;
                                                    uint32_t R12S6_key = r12s6;
                                                    uint32_t R12S6_input1 = getSBoxInputVal(ct, 6, 1);
                                                    uint32_t R12S6_input2 = getSBoxInputVal(ct_bar, 6, 1);
                                                    if ((SBOX[5][R12S6_input1 ^ R12S6_key] & 0x0a) != (R12_output1[20] << 3 | R12_output1[22] << 1))
                                                        continue;
                                                    if ((SBOX[5][R12S6_input2 ^ R12S6_key] & 0x0a) != (R12_output2[20] << 3 | R12_output2[22] << 1))
                                                        continue;
                                                    uint32_t tmp = SBOX[5][R12S6_input1 ^ R12S6_key];
                                                    R12_output1[21] = (tmp >> 2) & 1;
                                                    R12_output1[23] = (tmp) & 1;
                                                    tmp = SBOX[5][R12S6_input2 ^ R12S6_key];
                                                    R12_output2[21] = (tmp >> 2) & 1;
                                                    R12_output2[23] = (tmp) & 1;
                                                    // Round12 S7 keybit (36 41 31 48 54 45)
                                                    // Round12 S7 output (24 ~ 27) 24, 25, 27 know
                                                    for (uint32_t r12s7 = 0; r12s7 < 64; r12s7++) {
                                                        keybit[36] = (r12s7 >> 5) & 1;
                                                        keybit[41] = (r12s7 >> 4) & 1;
                                                        keybit[31] = (r12s7 >> 3) & 1;
                                                        keybit[48] = (r12s7 >> 2) & 1;
                                                        keybit[54] = (r12s7 >> 1) & 1;
                                                        keybit[45] = (r12s7) & 1;
                                                        uint32_t R12S7_key = r12s7;
                                                        uint32_t R12S7_input1 = getSBoxInputVal(ct, 7, 1);
                                                        uint32_t R12S7_input2 = getSBoxInputVal(ct_bar, 7, 1);
                                                        if ((SBOX[6][R12S7_input1 ^ R12S7_key] & 0x0d) != (R12_output1[24] << 3 | R12_output1[25] << 2 | R12_output1[27]))
                                                            continue;
                                                        if ((SBOX[6][R12S7_input2 ^ R12S7_key] & 0x0d) != (R12_output2[24] << 3 | R12_output2[25] << 2 | R12_output2[27]))
                                                            continue;
                                                        uint32_t tmp = SBOX[6][R12S7_input1 ^ R12S7_key];
                                                        R12_output1[26] = (tmp >> 1) & 1;
                                                        tmp = SBOX[6][R12S7_input2 ^ R12S7_key];
                                                        R12_output2[26] = (tmp >> 1) & 1;
                                                        // Round12 S8 keybit (38 34 42 28 49 52)
                                                        // Round12 output bit (28 29 30 31) 28 know
                                                        for (uint32_t r12s8 = 0; r12s8 < 64; r12s8++) {
                                                            keybit[38] = (r12s8 >> 5) & 1;
                                                            keybit[34] = (r12s8 >> 4) & 1;
                                                            keybit[42] = (r12s8 >> 3) & 1;
                                                            keybit[28] = (r12s8 >> 2) & 1;
                                                            keybit[49] = (r12s8 >> 1) & 1;
                                                            keybit[52] = (r12s8) & 1;
                                                            uint32_t R12S8_key = r12s8;
                                                            uint32_t R12S8_input1 = getSBoxInputVal(ct, 8, 1);
                                                            uint32_t R12S8_input2 = getSBoxInputVal(ct_bar, 8, 1);
                                                            if ((SBOX[7][R12S8_input1 ^ R12S8_key] & 0x08) != (R12_output1[28] << 3))
                                                                continue;
                                                            if ((SBOX[7][R12S8_input2 ^ R12S8_key] & 0x08) != (R12_output2[28] << 3))
                                                                continue;
                                                            uint32_t tmp = SBOX[7][R12S8_input1 ^ R12S8_key];
                                                            R12_output1[29] = (tmp >> 2) & 1;
                                                            R12_output1[30] = (tmp >> 1) & 1;
                                                            R12_output1[31] = (tmp) & 1;
                                                            tmp = SBOX[7][R12S8_input2 ^ R12S8_key];
                                                            R12_output2[29] = (tmp >> 2) & 1;
                                                            R12_output2[30] = (tmp >> 1) & 1;
                                                            R12_output2[31] = (tmp) & 1;
                                                            uint32_t keylist[4] = {R12S1_key, R12S2_key, R12S3_key, R12S4_key};
                                                            for (uint32_t i = 0; i < 4; i++) {
                                                                uint32_t tmp = SBOX[i][getSBoxInputVal(ct, i + 1, 1) ^ keylist[i]];
                                                                R12_output1[4 * i] = (tmp >> 3) & 1;
                                                                R12_output1[4 * i + 1] = (tmp >> 2) & 1;
                                                                R12_output1[4 * i + 2] = (tmp >> 1) & 1;
                                                                R12_output1[4 * i + 3] = (tmp) & 1;
                                                                tmp = SBOX[i][getSBoxInputVal(ct_bar, i + 1, 1) ^ keylist[i]];
                                                                R12_output2[4 * i] = (tmp >> 3) & 1;
                                                                R12_output2[4 * i + 1] = (tmp >> 2) & 1;
                                                                R12_output2[4 * i + 2] = (tmp >> 1) & 1;
                                                                R12_output2[4 * i + 3] = (tmp) & 1;
                                                            }
                                                            // right key register 30, 35, 46, 55 bit recover by brusteforcing
                                                            for (uint32_t key_bf = 0; key_bf < 16; key_bf++) {
                                                                keybit[30] = (key_bf >> 3) & 1;
                                                                keybit[35] = (key_bf >> 2) & 1;
                                                                keybit[46] = (key_bf >> 1) & 1;
                                                                keybit[55] = (key_bf) & 1;
                                                                byte candidateKey[8] = {0, };
                                                                uint8_t tmpKeybit[64] = {0, };
                                                                for (uint32_t i = 0; i < 56; i++) {
                                                                    tmpKeybit[PC1[i] - 1] = keybit[i];
                                                                }
                                                                for (uint32_t i = 0; i < 8; i++) {
                                                                    for (uint32_t j = 0; j <= 6; j++) {
                                                                        candidateKey[i] = (candidateKey[i] | tmpKeybit[8 * i + j]) << 1;
                                                                    }
                                                                }
                                                                
                                                                uint32_t candidateKeyInt[32];
                                                                des_key_setup(candidateKey, candidateKeyInt);
                                                                byte tmpC[8] = {0, };
                                                                DES(candidateKeyInt, pt, tmpC);
                                                                uint32_t isRightKey = false;
                                                                if (!memcmp(ct, tmpC, sizeof(tmpC)))
                                                                    isRightKey = true;
                                                                if (isRightKey) {
                                                                    printf("Right Key : ");
                                                                    print_bytes(candidateKey, 8);
                                                                    printf("P1 : ");
                                                                    print_bytes(pt, 8);
                                                                    printf("P2 : ");
                                                                    print_bytes(pt_bar, 8);
                                                                    return isRightKey;
                                                                }
                                                                S2N++;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}


/*
12R Right Pair is found!!
PT    : 11 5E F1 5C 4F 8E 3E 87 

PT Bar: 11 D6 72 58 56 EE 3E 87 

CT    : 37 78 D6 50 7D 87 60 1D 

CT Bar: 62 03 DF 75 7D 07 60 0F 

KEY   : C4 0E 2A 89 78 10 04 E1 
*/

int** getSurvivingPair(byte P[][8], byte P_bar[][8], byte T[][8], byte T_bar[][8], int POOL_SIZE, int MAX_PAIR) { // surviving pair�� index�� ��ȯ
  int** pairlist = (int**)malloc(sizeof(int*) * MAX_PAIR);
  for (int i = 0; i < MAX_PAIR; i++)
    pairlist[i] = (int*)malloc(sizeof(int) * 2);
  for (int i = 0; i < MAX_PAIR; i++) {
    pairlist[i][0] = -1;
    pairlist[i][1] = -1;
  }
  // S1, S2, S3�� output bit (8, 16, 22, 30), (12, 27, 1, 17), (23, 15, 29, 5)�� 0���� ���� 32��Ʈ ���� �������� ������ collision�� ã�Ƴ� ����
  // T, T_bar�� right�� �����ϸ� ��.
  std::vector<std::pair<int, int> > V(POOL_SIZE * 2); // (32��Ʈ ��, index)
  for (int i = 0; i < POOL_SIZE; i++) {
    // P�� (1, 5), (8, 12, 15), (16, 17, 22, 23), (27, 29, 30) ��° bit�� 0���� ��������
    // 10111011(BB) 01110110(76) 00111100(3C) 11101001(E9)
    V[i] = std::make_pair( (((T[i][4] << 24) | (T[i][5] << 16) | (T[i][6] << 8) | T[i][7])) & 0xBB763CE9, i );
    V[i + POOL_SIZE] = std::make_pair( (((T_bar[i][4] << 24) | (T_bar[i][5] << 16) | (T_bar[i][6] << 8) | T_bar[i][7])) & 0xBB763CE9, i + POOL_SIZE );
  }
  sort(V.begin(), V.end());
  int pairlist_idx = 0; // �������� ������ pairlist�� index
  for (int i = 0; i < 2 * POOL_SIZE - 1; i++) { // V[i], V[i+1]�� first�� �������� Ȯ���� ����. first�� �����Ѱ� 3�� �̻��̸� ��� ��츦 �������� ���� �� ������ �ʹ��� ����� Ȯ���� ������ ���̱� ������ �׳� ����
    if (V[i].first == V[i + 1].first && V[i].second < POOL_SIZE && V[i + 1].second >= POOL_SIZE) { // V[i]�� T�� �����ְ� V[i+1]�� T_bar�� �����־���ϹǷ� �߰��� ����
                                                     // ���� R1,11,12������ S-box�� ������ ���캸�� ������ ������ �������� Ȯ��. �� �� Ȯ���� 0.0745�� �������鼭 1.19���� pair�� ��Ƴ���
                                                     // 1. R1���� S1,S2,S3�� ������ ������ ������ �������� diff_table�� Ȯ��
                                                     // R1�� input ������ 00011001(19) 01100000(60) 00000000 00000000 
                                                     // S1�� input ���� : 000011
                                                     // S2�� input ���� : 110010
                                                     // S3�� input ���� : 101100
      int idx0 = V[i].second; // P�� �����Ǵ� index
      int idx1 = V[i + 1].second - POOL_SIZE; // P_bar�� �����Ǵ� index
      byte P_diff[8];
      byte C_diff[8];
      for (int i = 0; i < 8; i++) {
        P_diff[i] = P[idx0][i] ^ P_bar[idx1][i];
        C_diff[i] = T[idx0][i] ^ T_bar[idx1][i];
      }
      if (diff_table[0][0x03][getSBoxOutputVal(P_diff, 1, 0)] == 0) // S1�� 0x03�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      if (diff_table[1][0x32][getSBoxOutputVal(P_diff, 2, 0)] == 0) // S2�� 0x32�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      if (diff_table[2][0x2c][getSBoxOutputVal(P_diff, 3, 0)] == 0) // S3�� 0x2c�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      // 2. R11���� S1, S2, S3�� ������ ������ ������ �������� diff_table�� Ȯ��. R15���� S1, S2, S3�� output ������ Cipher�� right
      if (diff_table[0][0x03][getSBoxOutputVal(C_diff, 1, 1)] == 0) // S1�� 0x03�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      if (diff_table[1][0x32][getSBoxOutputVal(C_diff, 2, 1)] == 0) // S2�� 0x32�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      if (diff_table[2][0x2c][getSBoxOutputVal(C_diff, 3, 1)] == 0) // S3�� 0x2c�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      // 3. R12���� S1-S8�� ������ ������ ������ �������� diff_table�� Ȯ��
      // C_diff[0~3]�� 19(0001 1001) 60(0110 0000) 00 00�� XOR�� ���� F �Լ��� ����̴�.
      C_diff[0] ^= 0x19;
      C_diff[1] ^= 0x60;
      if (diff_table[0][getSBoxInputVal(C_diff, 1, 1)][getSBoxOutputVal(C_diff, 1, 0)] == 0) // S1�� input�� ���� P_diff�� �Ұ����� ������ ���
        continue;
      if (diff_table[1][getSBoxInputVal(C_diff, 2, 1)][getSBoxOutputVal(C_diff, 2, 0)] == 0)
        continue;

      if (diff_table[2][getSBoxInputVal(C_diff, 3, 1)][getSBoxOutputVal(C_diff, 3, 0)] == 0)
        continue;
      if (diff_table[3][getSBoxInputVal(C_diff, 4, 1)][getSBoxOutputVal(C_diff, 4, 0)] == 0)
        continue;
      if (diff_table[4][getSBoxInputVal(C_diff, 5, 1)][getSBoxOutputVal(C_diff, 5, 0)] == 0)
        continue;
      if (diff_table[5][getSBoxInputVal(C_diff, 6, 1)][getSBoxOutputVal(C_diff, 6, 0)] == 0)
        continue;
      if (diff_table[6][getSBoxInputVal(C_diff, 7, 1)][getSBoxOutputVal(C_diff, 7, 0)] == 0)
        continue;

      if (diff_table[7][getSBoxInputVal(C_diff, 8, 1)][getSBoxOutputVal(C_diff, 8, 0)] == 0)
        continue;
      // �� ��� filtering�� ����ߴٸ�
      pairlist[pairlist_idx][0] = idx0;
      pairlist[pairlist_idx][1] = idx1;
      pairlist_idx++; // pairlist�� �߰�
      if (pairlist_idx == MAX_PAIR) // ���� MAX_PAIR���� ����������
        return pairlist; // �׳� ��ȯ
    }
  }
  return pairlist;
}

int main(int argc, char *argv[])
{
    if (argc != 2) {
        printf("USAGE: ./DES_DC {PT or KEY}\n");
        return 1;
    }
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IONBF, 0);
    setvbuf(stderr, 0, _IONBF, 0);
    
    setDiffTable();
    uint64_t count_structure = 0;
    const int V_SIZE = 4096;
    byte P_list[V_SIZE][8];
    byte P_bar_list[V_SIZE][8];
    byte C_list[V_SIZE][8];
    byte C_bar_list[V_SIZE][8];
    byte pt_diff[8], ct_diff[8] = {0, };
    
    byte key[8] = { 0xc2, 0x54, 0x92, 0x10, 0x30, 0x02, 0xc2, 0x04};
    byte pt_bar[8], ct[8], ct_bar[8];
    byte pt[8] = { 0xc5, 0xb1, 0xba, 0x41, 0xf5, 0xab, 0x67, 0xf2};
    int MAX_PAIR = 100;
    int idx0, idx1;
    int count_right_pair = 0;
    // setRandomByte(key, sizeof(key)); // 임의의 키 셋팅
    des_key_setup(key, key_int); // subkey들 생성
    printf("KEY : ");
    print_bytes(key, 8);
    bool flag = false;

    // 여러가지 structure를 만들어서 테스팅 ㄱ
    if (!strcmp(argv[1], "PT")) {
        while (count_structure >= 0) {
            
            if (count_structure == 100) {
                printf("%lld structrures make %d right pairs\n", count_structure, count_right_pair);
                return 1;
            }
            
            count_structure++;
            if (count_structure % 10000 == 0) {
                printf("%lld structures are tested!!\n", count_structure);
            }
            // setRandomByte(pt, sizeof(pt)); // Plaintext 무작위 생성
            // P, P_bar, C, C_bar 완성시키기
            for (int i = 0; i < V_SIZE; i++) {
                setPtVariant(pt, P_list[i], i);
                memcpy(&P_bar_list[i], &P_list[i], 8);
                P_bar_list[i][4] ^= 0x19;
                P_bar_list[i][5] ^= 0x60;
                DES(key_int, P_list[i], C_list[i]);
                DES(key_int, P_bar_list[i], C_bar_list[i]);
            }
            // 평문과 암호문 쌍 중에서 right pair를 얻고
            int** pair_list = getPairList(P_list, P_bar_list, C_list, C_bar_list, V_SIZE, MAX_PAIR);
            for (int i = 0; i < MAX_PAIR; i++) {
                int idx0 = pair_list[i][0];            
                int idx1 = pair_list[i][1]; 
                if (idx0 != -1) { // pair 가 있는 곳
                    count_right_pair++;
                    printf("%d %d\n", idx0, idx1);
                    int result = isRightPath(key_int, P_list[idx0], P_bar_list[idx1]);
                    if (result == 12) {
                        printf("%d pairs are tested\n", count_right_pair);
                        printf("12R Right Pair is found!!\n");
                        printf("PT    : ");
                        print_bytes(P_list[idx0], 8);
                        printf("PT Bar: ");
                        print_bytes(P_bar_list[idx1], 8);
                        printf("CT    : ");
                        print_bytes(C_list[idx0], 8);
                        printf("CT Bar: ");
                        print_bytes(C_bar_list[idx1], 8);
                        printf("KEY   : ");
                        print_bytes(key, 8);
                        return 0;
                    } else if (result >= 4) {
                        printf("%ds Pairs are tested\n", count_right_pair);
                        printf("%dR pair is found!!\n", result);
                    }
                } else {
                    break;
                }
                // 이 중에서 해당 후보가 진짜로 맞는 path를 탔는지 검사떄린다
            }
            // 사용이 끝난 pair list속 포인터 모두 해제, 마지막으로 pair_list 자체 메모리 공간 해제
            for (int i = 0; i < MAX_PAIR; i++) {
                free(pair_list[i]);
            }
            free(pair_list);
        }
    } else if (!strcmp(argv[1], "KEY")) {
        while (count_structure >= 0 && !flag) {
            count_structure++;
            if (count_structure % 10000 == 0) {
                printf("%lld structures are tested!!\n", count_structure);
            }
            
            // setRandomByte(pt, sizeof(pt)); // Plaintext 무작위 생성
            // P, P_bar, C, C_bar 완성시키기
            for (int i = 0; i < V_SIZE; i++) {
                setPtVariant(pt, P_list[i], i);
                memcpy(&P_bar_list[i], &P_list[i], 8);
                P_bar_list[i][4] ^= 0x19;
                P_bar_list[i][5] ^= 0x60;
                DES(key_int, P_list[i], C_list[i]);
                DES(key_int, P_bar_list[i], C_bar_list[i]);
            }

            // 평문과 암호문 쌍 중에서 right pair를 얻고
            int** pair_list = getPairList(P_list, P_bar_list, C_list, C_bar_list, V_SIZE, MAX_PAIR);
            for (int i = 0; i < MAX_PAIR; i++) {
                int idx0 = pair_list[i][0];            
                int idx1 = pair_list[i][1]; 
                if (idx0 != -1) { // pair 가 있는 곳
                    count_right_pair++;
                    int result = recoverKey(P_list[idx0], C_list[idx0], P_bar_list[idx1], C_bar_list[idx1]);
                    if (result) {
                        printf("\nFound Key in %lldth structure\n", count_structure);
                        printf("Wrong key : %llu\n", S2N);
                        flag = true;
                        break;
                    }
                }
            }

            // 사용이 끝난 pair list속 포인터 모두 해제, 마지막으로 pair_list 자체 메모리 공간 해제
            for (int i = 0; i < MAX_PAIR; i++) {
                free(pair_list[i]);
            }
            free(pair_list);
        }
    }
}
/*
void recoverSubKey()
{
    // Byte pt[8] = {0x4e, 0xb3, 0xf8, 0xbd, 0x0c, 0xcf, 0x86, 0xc3};
    // Byte pt_bar[8] = {0x4a, 0x33, 0xf8, 0xa9, 0x15, 0xaf, 0x86, 0xc3};
    // Byte key[8] = {0x49, 0x44, 0xdd, 0xbc, 0xe0, 0xd1, 0x33, 0x58};
    byte pt[8] = {0xb3, 0x61, 0x53, 0xa2, 0x0e, 0xe8, 0xb1, 0x47};
    byte pt_bar[8] = {0xaa, 0x01, 0x53, 0xa2, 0x0e, 0xe8, 0xb1, 0x47};
    byte key[8] = {0x18, 0x7c, 0x16, 0x80, 0xe0, 0xd2, 0x85, 0x1d};
    byte ct[8], ct_bar[8], pt_diff[8], ct_diff[8] = {0, };
    des_key_setup(key, key_int);
    assert(check_is_path(pt, pt_bar) == 11);
    DES(key_int, pt, ct);
    DES(key_int, pt_bar, ct_bar);
    uint8_t keybits[56] = {0, };
    puts("Start");
    //print_bytes(ct, 8);
    //print_bytes(ct_bar, 8);
    for (int i = 0; i < 8; i++){
        pt_diff[i] = pt[i] ^ pt_bar[i];
        ct_diff[i] = ct[i] ^ ct_bar[i];
    }
    ct_diff[0] ^= 0x19;
    ct_diff[1] ^= 0x60;
    //print_bytes(pt_diff, 8);
    //print_bytes(ct_diff, 8);
    for (int i = 1; i <= 8; i++) {
        printf("S%d %d\n", i, getSBoxInputVal(ct_diff, i, 1));    
        printf("S%d %d\n", i, getSBoxOutputVal(ct_diff, i, 0));    
    }
    //return;
    // ROUND 11 의 S2 (21, 18, 5, 24, 11, 0) 라운드키부터 구해야 한다.
    for (int r11S2 = 0; r11S2 < 64; r11S2++) {
        keybits[21] = (r11S2 & 0x20) >> 5;
        keybits[18] = (r11S2 & 0x10) >> 4;
        keybits[5] = (r11S2 & 0x08) >> 3;
        keybits[24] = (r11S2 & 0x04) >> 2;
        keybits[11] = (r11S2 & 0x02) >> 1;
        keybits[0] = (r11S2 & 0x01);
        int R11S2_key = r11S2;
        int R11S2_input1 = getSBoxInputVal(ct, 2, 1);
        int R11S2_input2 = getSBoxInputVal(ct_bar, 2, 1);
        int R11S2_output1 = SBOX[1][R11S2_input1 ^ R11S2_key];
        int R11S2_output2 = SBOX[1][R11S2_input2 ^ R11S2_key];
        int R11S2_output_XOR = R11S2_output1 ^ R11S2_output2;
        int expected_R11S2_output_XOR = getSBoxOutputVal(ct, 2, 0) ^ getSBoxOutputVal(ct_bar, 2, 0) ^ 6;

        if (R11S2_output_XOR != expected_R11S2_output_XOR)
            continue;
        // ROUND 11 의 S3 (13, 9, 2, 22, 16, 26) 라운드키부터 구해야 한다.
        for (int r11S3 = 0; r11S3 < 64; r11S3++) {
            keybits[13] = (r11S3 & 0x20) >> 5;
            keybits[9] = (r11S3 & 0x10) >> 4;
            keybits[2] = (r11S3 & 0x08) >> 3;
            keybits[22] = (r11S3 & 0x04) >> 2;
            keybits[16] = (r11S3 & 0x02) >> 1;
            keybits[26] = (r11S3 & 0x01);
            int R11S3_key = r11S3;
            int R11S3_input1 = getSBoxInputVal(ct, 3, 1);
            int R11S3_input2 = getSBoxInputVal(ct_bar, 3, 1);
            int R11S3_output1 = SBOX[2][R11S3_input1 ^ R11S3_key];
            int R11S3_output2 = SBOX[2][R11S3_input2 ^ R11S3_key];
            int R11S3_output_XOR = R11S3_output1 ^ R11S3_output2;
            int expected_R11S3_output_XOR = getSBoxOutputVal(ct, 3, 0) ^ getSBoxOutputVal(ct_bar, 3, 0);

            if (R11S3_output_XOR != expected_R11S3_output_XOR)
                continue;
            // ROUND 11 의 S4 (6, 25, 17, 10, 3, 20) 라운드키부터 구해야 한다.
            for (int r11S4 = 0; r11S4 < 64; r11S4++) {
                keybits[6] = (r11S4 & 0x20) >> 5;
                keybits[25] = (r11S4 & 0x10) >> 4;
                keybits[17] = (r11S4 & 0x08) >> 3;
                keybits[10] = (r11S4 & 0x04) >> 2;
                keybits[3] = (r11S4 & 0x02) >> 1;
                keybits[20] = (r11S4 & 0x01);
                int R11S4_key = r11S4;
                int R11S4_input1 = getSBoxInputVal(ct, 4, 1);
                int R11S4_input2 = getSBoxInputVal(ct_bar, 4, 1);
                int R11S4_output1 = SBOX[3][R11S4_input1 ^ R11S4_key];
                int R11S4_output2 = SBOX[3][R11S4_input2 ^ R11S4_key];
                int R11S4_output_XOR = R11S4_output1 ^ R11S4_output2;
                int expected_R11S4_output_XOR = getSBoxOutputVal(ct, 4, 0) ^ getSBoxOutputVal(ct_bar, 4, 0) ^ 0x2;;
                // printf("%u %u\n", R11S4_output_XOR, expected_R11S4_output_XOR);
                if (R11S4_output_XOR != expected_R11S4_output_XOR)
                    continue;
                // ROUND 11 의 S5 (31, 42, 49, 55, 37, 45) 라운드키부터 구해야 한다.
                for (int r11S5 = 0; r11S5 < 64; r11S5++) {

                    keybits[31] = (r11S5 & 0x20) >> 5;
                    keybits[42] = (r11S5 & 0x10) >> 4;
                    keybits[49] = (r11S5 & 0x08) >> 3;
                    keybits[55] = (r11S5 & 0x04) >> 2;
                    keybits[37] = (r11S5 & 0x02) >> 1;
                    keybits[45] = (r11S5 & 0x01);
                    int R11S5_key = r11S5;
                    int R11S5_input1 = getSBoxInputVal(ct, 5, 1);
                    int R11S5_input2 = getSBoxInputVal(ct_bar, 5, 1);
                    int R11S5_output1 = SBOX[4][R11S5_input1 ^ R11S5_key];
                    int R11S5_output2 = SBOX[4][R11S5_input2 ^ R11S5_key];
                    int R11S5_output_XOR = R11S5_output1 ^ R11S5_output2;
                    int expected_R11S5_output_XOR = getSBoxOutputVal(ct, 5, 0) ^ getSBoxOutputVal(ct_bar, 5, 0) ^ 0x8;
                    // printf("%u %u\n", R11S5_output_XOR, expected_R11S5_output_XOR);
                    if (R11S5_output_XOR != expected_R11S5_output_XOR)
                        continue;
                    // ROUND 11 의 S6 (48, 30, 41, 35, 51, 38) 라운드키부터 구해야 한다.
                    for (int r11S6 = 0; r11S6 < 64; r11S6++) {
                        keybits[48] = (r11S6 & 0x20) >> 5;
                        keybits[30] = (r11S6 & 0x10) >> 4;
                        keybits[41] = (r11S6 & 0x08) >> 3;
                        keybits[35] = (r11S6 & 0x04) >> 2;
                        keybits[51] = (r11S6 & 0x02) >> 1;
                        keybits[38] = (r11S6 & 0x01);
                        int R11S6_key = r11S6;
                        int R11S6_input1 = getSBoxInputVal(ct, 6, 1);
                        int R11S6_input2 = getSBoxInputVal(ct_bar, 6, 1);
                        int R11S6_output1 = SBOX[4][R11S6_input1 ^ R11S6_key];
                        int R11S6_output2 = SBOX[4][R11S6_input2 ^ R11S6_key];
                        int R11S6_output_XOR = R11S6_output1 ^ R11S6_output2;
                        int expected_R11S6_output_XOR = getSBoxOutputVal(ct, 6, 0) ^ getSBoxOutputVal(ct_bar, 6, 0) ^ 10;
                        // printf("%u %u\n", R11S6_output_XOR, expected_R11S6_output_XOR);
                        if (R11S6_output_XOR != expected_R11S6_output_XOR)
                            continue;
                        // 이제 Sbox로 할 수 있는거 다했고 S1, S7, S8는 차분이 0이라서 
    // (4, 7, 1, 14, 19, 23, 34, 39, 29, 46, 52, 43, 36, 32, 40, 54, 47, 50, 8, 12, 15, 27, 28, 33, 44, 53)
                        // 26 bit 전수조사,,,,
                        for (int bruteforce = 0; bruteforce < (int)pow(2, 26); bruteforce++) {
                            keybits[4] = (bruteforce & 0x2000000) >> 25;
                            keybits[7] = (bruteforce & 0x1000000) >> 24;
                            keybits[1] = (bruteforce & 0x0800000) >> 23;
                            keybits[14] = (bruteforce & 0x400000) >> 22;
                            keybits[19] = (bruteforce & 0x200000) >> 21;
                            keybits[23] = (bruteforce & 0x100000) >> 20;
                            keybits[34] = (bruteforce & 0x80000) >> 19;
                            keybits[39] = (bruteforce & 0x40000) >> 18;
                            keybits[29] = (bruteforce & 0x20000) >> 17;
                            keybits[46] = (bruteforce & 0x10000) >> 16;
                            keybits[52] = (bruteforce & 0x8000) >> 15;
                            keybits[43] = (bruteforce & 0x4000) >> 14;
                            keybits[36] = (bruteforce & 0x2000) >> 13;
                            keybits[32] = (bruteforce & 0x1000) >> 12;
                            keybits[40] = (bruteforce & 0x800) >> 11;
                            keybits[54] = (bruteforce & 0x400) >> 10;
                            keybits[47] = (bruteforce & 0x200) >> 9;
                            keybits[50] = (bruteforce & 0x100) >> 8;
                            keybits[8] = (bruteforce & 0x80) >> 7;
                            keybits[12] = (bruteforce & 0x40) >> 6;
                            keybits[15] = (bruteforce & 0x20) >> 5;
                            keybits[27] = (bruteforce & 0x10) >> 4;
                            keybits[28] = (bruteforce & 8) >> 3;
                            keybits[33] = (bruteforce & 4) >> 2;
                            keybits[44] = (bruteforce & 2) >> 1;
                            keybits[53] = (bruteforce & 1);
                            byte candidateKey[8] = {0, };
                            uint8_t tmpKeyBit[64] = {0, };
                            for (int i = 0; i < 56; i++) {
                                tmpKeyBit[PC1[i] - 1] = keybits[i];
                            }
                            for (int i = 0; i < 8; i++) {
                                for (int j = 0; j < 7; j++) {
                                    candidateKey[i] = (candidateKey[i] | tmpKeyBit[8 * i + j]) << 1;
                                }
                            }
                            des_key_setup(candidateKey, key_int);
                            byte tmp_result[8] = {0, };
                            DES(key_int, pt, tmp_result);
                            if (!memcmp(tmp_result, ct, 8)) {
                                printf("Found key!!: ");
                                print_bytes(candidateKey, 8);   
                                return ;
                            }
                        }
                        printf("Here?\n");
                    }
                }
            }
        }
    }
    // printf("%u %u\n", (subkeys[10][0] & 0x03) << 4 | (subkeys[10][1] & 0xf0) >> 4, (subkeys[10][1] & 0x0f) << 2 | subkeys[10][2] >> 6);
}
*/


// make 1 structure and test get right pairs
int** getPairList(byte P_list[4096][8], byte P_bar_list[4096][8], byte C_list[4096][8], byte C_bar_list[4096][8], int V_SIZE, int MAX_PAIR)
{
    int** pair_list = (int**)malloc(sizeof(int*) * MAX_PAIR);
    byte pt_diff[8], ct_diff[8];
    for (int i = 0; i < MAX_PAIR; i++) {
        pair_list[i] = (int*)malloc(sizeof(int) * 2);
        pair_list[i][0] = -1;
        pair_list[i][1] = -1;
    }
    std::vector< std::pair<int, int> > V(2 * V_SIZE);
    int idx_pair_list = 0;
    /*
    std::unordered_map< uint32_t, uint32_t > M;
    for (int i = 0; i < V_SIZE; i++) {
        M.insert(std::make_pair( (((C_list[i][4] << 24) | (C_list[i][5] << 16) | (C_list[i][6] << 8) | C_list[i][7])) & 0xBB763CE9, i ));
        // M[(((C_bar_list[i][4] << 24) | (C_bar_list[i][5] << 16) | (C_bar_list[i][6] << 8) | C_bar_list[i][7])) & 0xBB763CE9] = i + V_SIZE;
    }
    for (int i = 0; i < V_SIZE; i++) {
        std::unordered_map< uint32_t, uint32_t >::iterator tmp = M.find((((C_bar_list[i][4] << 24) | (C_bar_list[i][5] << 16) | (C_bar_list[i][6] << 8) | C_bar_list[i][7])) & 0xBB763CE9);
        if (tmp != M.end()) {
            int idx_C_list = tmp->second;
            int idx_C_bar_list = i;
            byte pt_diff[8], ct_diff[8];
            for (int idx = 0; idx < 8; idx++) {
                pt_diff[idx] = P_list[idx_C_list][idx] ^ P_bar_list[idx_C_bar_list][idx];
                ct_diff[idx] = C_list[idx_C_list][idx] ^ C_bar_list[idx_C_bar_list][idx];
            }
            // 12라운드일때, 평문의 차분과, 암호문의 차분을 통해 R1, R11, R12 에서 검사할 수 있는 차분들을 다 검사한다.
            if (diff_table[0][0x3][getSBoxOutputVal(pt_diff, 1, 0)] == 0)
                continue;
            if (diff_table[0][0x32][getSBoxOutputVal(pt_diff, 2, 0)] == 0)
                continue;
            if (diff_table[0][0x2c][getSBoxOutputVal(pt_diff, 3, 0)] == 0)
                continue;
            if (diff_table[0][0x3][getSBoxOutputVal(ct_diff, 1, 1)] == 0)
                continue;
            if (diff_table[0][0x32][getSBoxOutputVal(ct_diff, 2, 1)] == 0)
                continue;
            if (diff_table[0][0x2c][getSBoxOutputVal(ct_diff, 3, 1)] == 0)
                continue;
            
            ct_diff[0] ^= 0x19;
            ct_diff[1] ^= 0x60;

            if (diff_table[0][getSBoxInputVal(ct_diff, 1, 1)][getSBoxOutputVal(ct_diff, 1, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 2, 1)][getSBoxOutputVal(ct_diff, 2, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 3, 1)][getSBoxOutputVal(ct_diff, 3, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 4, 1)][getSBoxOutputVal(ct_diff, 4, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 5, 1)][getSBoxOutputVal(ct_diff, 5, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 6, 1)][getSBoxOutputVal(ct_diff, 6, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 7, 1)][getSBoxOutputVal(ct_diff, 7, 0)] == 0)
                continue;
            if (diff_table[0][getSBoxInputVal(ct_diff, 8, 1)][getSBoxOutputVal(ct_diff, 8, 0)] == 0)
                continue;
            
            // 이제 모든 pair 통과 그러면 return list에 포함
            pair_list[idx_pair_list][0] = idx_C_list;
            pair_list[idx_pair_list][1] = idx_C_bar_list;
            idx_pair_list++;
            if (idx_pair_list == MAX_PAIR) {
                return pair_list;
            }
        }
    }
    return pair_list;
    */
    // 적절한 pair 구하기 1라운드 함수 와 left의 차분의 합이 0이 되게 하는
    for (int i = 0; i < V_SIZE; i++) {
        // 암호문의 left에서 (1, 5), (8, 12, 15), (16, 17, 22, 23), (27, 29, 30) 을 0으로 만들고 () sorting해서 값이 같은 것들끼리 pair
        // 0xBB763CE9 로 and 연산
        // 우선 C_list의 암호문의 오른쪽의 S1, S2, S3의 output을 제외한 나머지 20비트가 0이어야 한다. 그리고 이제 찾느다.
        V[i] = std::make_pair( (((C_list[i][4] << 24) | (C_list[i][5] << 16) | (C_list[i][6] << 8) | C_list[i][7])) & 0xBB763CE9, i );
        V[i + V_SIZE] = std::make_pair( (((C_bar_list[i][4] << 24) | (C_bar_list[i][5] << 16) | (C_bar_list[i][6] << 8) | C_bar_list[i][7])) & 0xBB763CE9, i + V_SIZE );
    }

    sort(V.begin(), V.end());
    idx_pair_list = 0;
    for (int i = 0; i < 2 * V_SIZE - 1; i++) {
        // found item in C_bar_list's item which has same value of C_list's item's 20 bit position
        if (V[i].first == V[i + 1].first && V[i].second < V_SIZE && V[i + 1].second >= V_SIZE)  {
            // 각각의 20 비트 값이 같은 pair 마다 pt_diff, ct_diff 계산해서
            int idx_C_list = V[i].second;
            int idx_C_bar_list = V[i + 1].second - V_SIZE;
            byte pt_diff[8], ct_diff[8];

            for (int idx = 0; idx < 8; idx++) {
                pt_diff[idx] = P_list[idx_C_list][idx] ^ P_bar_list[idx_C_bar_list][idx];
                ct_diff[idx] = C_list[idx_C_list][idx] ^ C_bar_list[idx_C_bar_list][idx];
            }
            // 12라운드일때, 평문의 차분과, 암호문의 차분을 통해 R1, R11, R12 에서 검사할 수 있는 차분들을 다 검사한다.
            if (diff_table[0][0x3][getSBoxOutputVal(pt_diff, 1, 0)] == 0)
                continue;
            if (diff_table[1][0x32][getSBoxOutputVal(pt_diff, 2, 0)] == 0)
                continue;
            if (diff_table[2][0x2c][getSBoxOutputVal(pt_diff, 3, 0)] == 0)
                continue;
            if (diff_table[0][0x3][getSBoxOutputVal(ct_diff, 1, 1)] == 0)
                continue;
            if (diff_table[1][0x32][getSBoxOutputVal(ct_diff, 2, 1)] == 0)
                continue;
            if (diff_table[2][0x2c][getSBoxOutputVal(ct_diff, 3, 1)] == 0)
                continue;
            
            ct_diff[0] ^= 0x19;
            ct_diff[1] ^= 0x60;

            if (diff_table[0][getSBoxInputVal(ct_diff, 1, 1)][getSBoxOutputVal(ct_diff, 1, 0)] == 0)
                continue;
            if (diff_table[1][getSBoxInputVal(ct_diff, 2, 1)][getSBoxOutputVal(ct_diff, 2, 0)] == 0)
                continue;
            if (diff_table[2][getSBoxInputVal(ct_diff, 3, 1)][getSBoxOutputVal(ct_diff, 3, 0)] == 0)
                continue;
            if (diff_table[3][getSBoxInputVal(ct_diff, 4, 1)][getSBoxOutputVal(ct_diff, 4, 0)] == 0)
                continue;
            if (diff_table[4][getSBoxInputVal(ct_diff, 5, 1)][getSBoxOutputVal(ct_diff, 5, 0)] == 0)
                continue;
            if (diff_table[5][getSBoxInputVal(ct_diff, 6, 1)][getSBoxOutputVal(ct_diff, 6, 0)] == 0)
                continue;
            if (diff_table[6][getSBoxInputVal(ct_diff, 7, 1)][getSBoxOutputVal(ct_diff, 7, 0)] == 0)
                continue;
            if (diff_table[7][getSBoxInputVal(ct_diff, 8, 1)][getSBoxOutputVal(ct_diff, 8, 0)] == 0)
                continue;


            // 이제 모든 pair 통과 그러면 return list에 포함
            pair_list[idx_pair_list][0] = idx_C_list;
            pair_list[idx_pair_list][1] = idx_C_bar_list;
            idx_pair_list++;
            if (idx_pair_list == MAX_PAIR) {
                return pair_list;
            }
            
        }
    }
    return pair_list;
}


void setPtVariant(byte pt[], byte variant[], int i)
{
    // S1, S2, S3의 output bit는 permutation을 거치면 각각 (1, 5), (8, 12, 15), (16, 17, 22, 23), (27, 29, 30) 번째 bit에 들어가게 된다.
    for (int idx = 0; idx < 8; idx++)
        variant[idx] = pt[idx];
    
    variant[0] ^= ((i & 1) << 6); i >>= 1; // i의 마지막 bit를 variant의 1번째 bit에 XOR하고 i의 마지막 bit를 제거
    variant[0] ^= ((i & 1) << 2); i >>= 1; // variant의 5번째 bit  
    variant[1] ^= ((i & 1) << 7); i >>= 1; // variant의 8번째 bit
    variant[1] ^= ((i & 1) << 3); i >>= 1; // variant의 12번째 bit
    variant[1] ^= (i & 1); i >>= 1; // variant의 15번째 bit
    variant[2] ^= ((i & 1) << 7); i >>= 1; // variant의 16번째 bit
    variant[2] ^= ((i & 1) << 6); i >>= 1; // variant의 17번째 bit
    variant[2] ^= ((i & 1) << 1); i >>= 1; // variant의 22번째 bit
    variant[2] ^= (i & 1); i >>= 1; // variant의 23번째 bit
    variant[3] ^= ((i & 1) << 4); i >>= 1; // variant의 27번째 bit
    variant[3] ^= ((i & 1) << 2); i >>= 1; // variant의 29번째 bit
    variant[3] ^= ((i & 1) << 1); // variant의 30번째 bit
    
}
/*
int check_is_path(byte pt[], byte pt_bar[])
{
    // skip IP, FP process
    // 1. split into left_half and right_half
    byte left[4] = {0, };
    byte left_bar[4] = {0, };
    byte right[4] = {0, };
    byte right_bar[4] = {0, };
    byte tmp[4] = {0, };
    byte tmp_bar[4] = {0, };
    byte expanded_right[6];
    byte expanded_right_bar[6];
    byte SBOX_buf[8];
    byte SBOX_buf_bar[8];
    byte xor_with_left[4];
    byte xor_with_left_bar[4];
    memcpy(left, pt, 4); // 32bits
    memcpy(left_bar, pt_bar, 4); // 32bits
    memcpy(right, &pt[4], 4); // 32bits
    memcpy(right_bar, &pt_bar[4], 4); // 32bits
    
    for (int r = 0; r < ROUNDS; r++)
    {
        
        // 2. start feistal expansion permutation -> key xor -> sbox -> last permutation
        permutate(right, expanded_right, E, 48);
        permutate(right_bar, expanded_right_bar, E, 48);
        for (int idx = 0; idx < 6; idx++)
        {
            expanded_right[idx] ^= subkeys[r][idx];
            expanded_right_bar[idx] ^= subkeys[r][idx];
        }
        // cleanup SBOX_buf
        memset(SBOX_buf, 0, sizeof(SBOX_buf));
        memset(SBOX_buf_bar, 0, sizeof(SBOX_buf_bar));
        SBOX_buf[0] = expanded_right[0] >> 2;
        SBOX_buf[1] = (expanded_right[0] & 0x03) << 4 | expanded_right[1] >> 4;
        SBOX_buf[2] = (expanded_right[1] & 0x0f) << 2 | expanded_right[2] >> 6;
        SBOX_buf[3] = expanded_right[2] & 0x3f;
        SBOX_buf[4] = expanded_right[3] >> 2;
        SBOX_buf[5] = (expanded_right[3] & 0x03) << 4 | expanded_right[4] >> 4;
        SBOX_buf[6] = (expanded_right[4] & 0x0f) << 2 | expanded_right[5] >> 6;
        SBOX_buf[7] = expanded_right[5] & 0x3f;
        SBOX_buf_bar[0] = expanded_right_bar[0] >> 2;
        SBOX_buf_bar[1] = (expanded_right_bar[0] & 0x03) << 4 | expanded_right_bar[1] >> 4;
        SBOX_buf_bar[2] = (expanded_right_bar[1] & 0x0f) << 2 | expanded_right_bar[2] >> 6;
        SBOX_buf_bar[3] = expanded_right_bar[2] & 0x3f;
        SBOX_buf_bar[4] = expanded_right_bar[3] >> 2;
        SBOX_buf_bar[5] = (expanded_right_bar[3] & 0x03) << 4 | expanded_right_bar[4] >> 4;
        SBOX_buf_bar[6] = (expanded_right_bar[4] & 0x0f) << 2 | expanded_right_bar[5] >> 6;
        SBOX_buf_bar[7] = expanded_right_bar[5] & 0x3f;
        memset(tmp, 0, sizeof(tmp));
        memset(tmp_bar, 0, sizeof(tmp_bar));
        for (int idx = 0; idx < 8; idx++)
        {
            // int SBOX_idx = (SBOX_buf[idx] >> 4) & 0x02 | (SBOX_buf[idx] & 1);
            // SBOX_idx = SBOX_idx * 16 + ((SBOX_buf[idx] >> 1) & 0x0f);
            tmp[idx / 2] |= SBOX[idx][SBOX_buf[idx]] << 4 * (1 - idx % 2);
            tmp_bar[idx / 2] |= SBOX[idx][SBOX_buf_bar[idx]] << 4 * (1 - idx % 2);
        }
        
        permutate(tmp, xor_with_left, P, 32);
        permutate(tmp_bar, xor_with_left_bar, P, 32);
        for (int idx = 0; idx < sizeof(left); idx++)
        {
            left[idx] ^= xor_with_left[idx];
            left_bar[idx] ^= xor_with_left_bar[idx];
        }
        
        
        if (r == 1) {
            if (memcmp(left, left_bar, 4)) {
                return 2;
            }
        } else if (r == 3) {
            if (memcmp(left, left_bar, 4)) {
                return 4;
            }
        } else if (r == 5) {
            if (memcmp(left, left_bar, 4)) {
                return 6;
            }
        } else if (r == 7) {
            if (memcmp(left, left_bar, 4)) {
                return 8;
            }
        }
        
        // 만약 마지막 라운드가 아니라면 left, right swap
        if (r != ROUNDS - 1)
        {
            memcpy(tmp, right, sizeof(right));
            memcpy(right, left, sizeof(left));
            memcpy(left, tmp, sizeof(tmp));
            
            memcpy(tmp_bar, right_bar, sizeof(right_bar));
            memcpy(right_bar, left_bar, sizeof(left_bar));
            memcpy(left_bar, tmp_bar, sizeof(tmp_bar));
        }

    }
    return 11;
}
*/

void setRandomByte(byte content[], int bytesNum)
{
    std::random_device rd;

    std::mt19937 gen(rd());

    std::uniform_int_distribution<int> dis(0, 0xff);

    for (int i = 0; i < bytesNum; i++)
    {
        content[i] = dis(gen);
    }
}


void setDiffTable(void)
{
    for (int idx = 0; idx < 8; idx++)
        for (int i = 0; i < 64; i++)
            for (int j = 0; j < 64; j++)
                diff_table[idx][i^j][SBOX[idx][i] ^ SBOX[idx][j]]++;
}


/*
void DES(Byte pt[], Byte ct[])
{
    // skip IP, FP process
    // 1. split into left_half and right_half
    Byte left[4] = {0, };
    Byte right[4] = {0, };
    Byte tmp[4] = {0, };
    Byte expanded_right[6];
    Byte SBOX_buf[8];
    Byte xor_with_left[4];
    memcpy(left, pt, 4); // 32bits
    memcpy(right, &pt[4], 4); // 32bits
    
    for (int r = 0; r < ROUNDS; r++)
    {
        // 2. start feistal expansion permutation -> key xor -> sbox -> last permutation
        permutate(right, expanded_right, E, 48);
        for (int idx = 0; idx < 6; idx++)
        {
            expanded_right[idx] ^= subkeys[r][idx];
        }
        // cleanup SBOX_buf
        memset(SBOX_buf, 0, sizeof(SBOX_buf));
        SBOX_buf[0] = expanded_right[0] >> 2;
        SBOX_buf[1] = (expanded_right[0] & 0x03) << 4 | expanded_right[1] >> 4;
        SBOX_buf[2] = (expanded_right[1] & 0x0f) << 2 | expanded_right[2] >> 6;
        SBOX_buf[3] = expanded_right[2] & 0x3f;
        SBOX_buf[4] = expanded_right[3] >> 2;
        SBOX_buf[5] = (expanded_right[3] & 0x03) << 4 | expanded_right[4] >> 4;
        SBOX_buf[6] = (expanded_right[4] & 0x0f) << 2 | expanded_right[5] >> 6;
        SBOX_buf[7] = expanded_right[5] & 0x3f;
        memset(tmp, 0, sizeof(tmp));
        for (int idx = 0; idx < 8; idx++)
        {
            // int SBOX_idx = (SBOX_buf[idx] >> 4) & 0x02 | (SBOX_buf[idx] & 1);
            // SBOX_idx = SBOX_idx * 16 + ((SBOX_buf[idx] >> 1) & 0x0f);
            tmp[idx / 2] |= SBOX[idx][SBOX_buf[idx]] << 4 * (1 - idx % 2);
        }
        permutate(tmp, xor_with_left, P, 32);
        for (int idx = 0; idx < sizeof(left); idx++)
        {
            left[idx] ^= xor_with_left[idx];
        }
        // 만약 마지막 라운드가 아니라면 left, right swap
        if (r != ROUNDS - 1)
        {
            memcpy(tmp, right, sizeof(right));
            memcpy(right, left, sizeof(left));
            memcpy(left, tmp, sizeof(tmp));
        }
    }
    memcpy(ct, left, sizeof(left));
    memcpy(&ct[4], right, sizeof(right));
}


void check_which_sbox(int key_bit)
{
    int row, col;
    int bit_left, bit_right = 0;
    std::pair <int, int> bit_loc = std::make_pair(-1, -1);
    for (int i = 0; i < 24; i++)
    {
        bit_left = subkeys[0][i / 8 + 3] >> (7 - (i % 8)); 
        bit_right = subkeys[10][i / 8 + 3] >> (7 - (i % 8));
        if (bit_left & 1)
            bit_loc.first = i; // 첫번째 subkey에서 1이 몇번 째 비트에서 처음 발견됬는지
        if (bit_right & 1)
            bit_loc.second = i; // 마지막 11라운드 subkey에서 1이 몇번 째 비트에서 처음 발견됬는지
    }
    printf("%d'th bit up =>  S%d's %dth input and S%d's %dth input are influenced\n", key_bit + 28, bit_loc.first / 6 + 5, bit_loc.first % 6, bit_loc.second / 6 + 5, bit_loc.second % 6);
}

void generate_subkeys(uint32_t left, uint32_t right)
{
    uint32_t left_reg = left;
    uint32_t right_reg = right;
    byte before_pc2[7] = {0, };
    u64 tmp = 0;
    for (int i = 0; i < ROUNDS; i++)
    {
        left_reg = left_reg << keysh[i] | (left_reg >> (32 - keysh[i]) << 4);
        right_reg = right_reg << keysh[i] | (right_reg >> (32 - keysh[i]) << 4);
        // printf("%08llX %08llX\n", (uint64_t)left_reg << 24, (uint64_t)right_reg >> 4);
        tmp = (uint64_t)left_reg << 24 | (right_reg >> 4);
        // printf("%llX\n", tmp);
        memset(before_pc2, 0, sizeof(before_pc2));
        for (int j = 0; j < 56; j++)
        {
            before_pc2[j / 8] |= (tmp >> (55 - j) & 1) << (7 - (j % 8));
        }
        // print_bytes(before_pc2, 7);
        permutate(before_pc2, subkeys[i], PC2, 48);
        // print_bytes(subkeys[i], 6);

    }
}


void key_schedule(byte key[]) {
    byte key_permuated[7] = {0, };
    uint32_t left_reg, right_reg, left, right = 0;
    // puts("Start key permuation");
    permutate(key, key_permuated, PC1, 56);
    left_reg = key_permuated[0] << 24 | key_permuated[1] << 16 | key_permuated[2] << 8 | key_permuated[3] & 0xf0;
    right_reg = key_permuated[3] << 24 | key_permuated[4] << 16 | key_permuated[5] << 8 | key_permuated[6];
    right_reg <<= 4;
    generate_subkeys(left_reg, right_reg);
}

void permutate(byte in[], byte out[], uint8_t table[], int num)
{
    // before permuation, cleanup out buffer
    memset(out, 0, num / 8);
    for (int idx = 0; idx < num; idx++)
    {
        int bit_idx = table[idx] - 1;
        int new_bit_idx = bit_idx % 8;
        int new_byte_idx = bit_idx / 8;
        out[idx / 8] |= ((in[new_byte_idx] >> (7 - new_bit_idx)) & 1) << (7 - (idx % 8));
    }
}
*/
void print_bytes(byte b[], int num)
{
    for(int i = 0; i < num; i++)
    {
        printf("%02X ", b[i]);
        if (i % 8 == 7)
            puts("");
    }
    puts("");
}
